#!/usr/bin/python
from collections import OrderedDict
import re
import shutil
import os
import argparse

CFG_DEFAULT_COLOR_FILE="wow.vim"

CFG_COLORS=[
    ["DeathKnight", "DK", 1, 196, 30, 59],
    ["Monk", "Mnk", 2, 85, 138, 132],
    ["DarkRogue", "DkR", 3, 193, 186, 67],
    ["Shaman", "Sha", 4, 0, 112, 222],
    ["DarkWarlock", "DkW", 5, 87, 65, 146],
    ["Warrior", "War", 6, 199, 156, 110],
    ["Paladin", "Pal", 9, 245, 140, 186],
    ["Hunter", "Hun", 10, 171, 212, 115],
    ["Rogue", "Rog", 11, 255, 245, 105],
    ["Mage", "Mag", 12, 105, 204, 240],
    ["Warlock", "Lck", 13, 148, 130, 201],
    ["Druid", "Dru", 14, 255, 125, 10],
    ["Priest", "Pri", 15, 238, 236, 225],

    ["Black", "Blk", 0, 0, 0, 0],
    ["White", "Whi", 231, 255, 255, 255],
]

CFG_256 = True

# ANSI magic
ANSI_ESC='\033'
ANSI_UNDER = 4
ANSI_256_FG = 38
ANSI_256_BG = 48
ANSI_256 = 5
ANSI_FG = 30
ANSI_BG = 40

# Language Syntax
# " KEYWORD Group [[understyle_color] UNDERSTYLE] [fg_color] [on bg_color]
KEYWORD = "AC:"
MODIFIER = "MOD"
AUTOGENERATED_BEGIN = "BEGIN_AUTOGENERATED"
AUTOGENERATED_END = "END_AUTOGENERATED"
UNDERSTYLES = { "_":"underline", "~":"undercurl" }

class Color:
    def __init__(self, name, short, pal_index, r, g, b):
        self.name = name
        self.short = short
        self.pal_index = pal_index
        self.r = r
        self.g = g
        self.b = b

    def __str__(self):
        return "Base: {} {} ({},{},{})".format(
            self.name, self.pal_index, self.r, self.g, self.b)

    def is_bg(self):
        if CFG_256:
            return True
        else:
            return self.pal_index < 8

    def is_gray(self):
        if (self.palette == 0 or
            self.palette == 7 or
            self.palette == 8 or
            self.palette >= 231):
            return True
        else:
            return False

    def gui_name(self):
        return '#{:02x}{:02x}{:02x}'.format(self.r, self.g, self.b)

    def cterm_name(self):
        return self.pal_index

    def rgb_txt(self):
        return '{:3d} {:3d} {:3d} {}'.format(self.r,
                                             self.g,
                                             self.b,
                                             self.name)

    def color_db_plist(self):
        return (
            '<key>{}</key>\n' +
            '<integer>{:03d}{:03d}{:03d}</integer>'.format(
                self.name, self.r, self.g, self.b
            )
        )

class Style:
    """Defines a full color style with foreground, background and
    underline/undercurl
    """

    def __init__(self,
                 hi_grp,
                 fg, bg=None,
                 understyle=None, understyle_color=None,
                 mod=False,
                 msg=""):
        self.hi_grp = hi_grp
        self.mod = mod
        self.fg = fg
        self.bg = bg
        self.understyle = understyle
        self.understyle_color = understyle_color
        self.msg = msg

    def __str__(self):
        return "Style: hi_grp={} fg={} bg={} us={} us_c={}".format(
            self.hi_grp,
            self.fg.name,
            self.bg.name,
            self.understyle,
            self.understyle_color.name)

    def vim(self):
        # XXX: cterm xor (ctermfg or ctermbg) -- recommended for DOS compat.

        fg_cterm = "fg"
        fg_gui = "fg"
        if self.fg:
            fg_cterm = self.fg.cterm_name()
            fg_gui = self.fg.gui_name()
        elif self.mod:
            fg_cterm = "NONE"
            fg_gui = "NONE"

        bg_cterm = "bg"
        bg_gui = "bg"
        if self.bg:
            bg_cterm = self.bg.cterm_name()
            bg_gui = self.bg.gui_name()
        elif self.mod:
            bg_cterm = "NONE"
            bg_gui = "NONE"

        us = "NONE"
        if self.understyle:
            us = self.understyle

        usc = "NONE"
        if self.understyle_color:
            usc = self.understyle_color.gui_name()

        s = []
        s.append('hi {}'.format(self.hi_grp))
        s.append('cterm={}'.format(us))
        s.append('ctermfg={}'.format(fg_cterm))
        s.append('ctermbg={}'.format(bg_cterm))
        s.append('gui={}'.format(us))
        s.append('guisp={}'.format(usc))
        s.append('guifg={}'.format(fg_gui))
        s.append('guibg={}'.format(bg_gui))
        return ' '.join(s)

    def ansi_open(self):
        ansi_attrs = []
        if self.fg:
            if not CFG_256:
                ansi_attrs.append(str(self.fg.pal_index // 8))
                ansi_attrs.append(str(ANSI_FG + self.fg.pal_index % 8))
            else:
                ansi_attrs.append(str(ANSI_256_FG))
                ansi_attrs.append(str(ANSI_256))
                ansi_attrs.append(str(self.fg.pal_index))
        if self.bg:
            if not CFG_256:
                ansi_attrs.append(str(ANSI_BG + self.bg.pal_index % 8))
            else:
                ansi_attrs.append(str(ANSI_256_BG))
                ansi_attrs.append(str(ANSI_256))
                ansi_attrs.append(str(self.bg.pal_index))
        if self.understyle:
            ansi_attrs.append(str(ANSI_UNDER))
        return "{}[{}m".format(ANSI_ESC, ';'.join(ansi_attrs))

    def ansi_close(self):
        return "{}[0m".format(ANSI_ESC)

    def test_str(self, txt=""):
        s = []
        s.append(self.ansi_open())
        if txt:
            s.append(txt)
        else:
            s.append(self.hi_grp)
        s.append(self.ansi_close())
        return ''.join(s)

class ParseError(Exception):
    def __init__(self, line, msg):
        self.line = line
        self.msg = msg
    def __str__(self):
        return '{}\n{}'.format(self.msg, self.line)

class StyleMaster():
    def __init__(self):
        self.init_palette()

    def init_palette(self):
        self.palette = OrderedDict()

        # Add colors to palette
        for name, short, i, r, g, b in CFG_COLORS:
            self.palette[name] = Color(name, short, i, r, g, b)

        # Add grays to palette

        # EXPLANATION OF GRAY CHICANERY
        #
        # Goal is to have Gray10..Gray90 where n = %Gray in 10% increments
        #
        # Unfortunately, its not clear how you can redefine xterm pallete 
        # colors above 16, so for most, we approximate based on closest 
        # pre-defined color to 10% increments.
        #
        # However, we do have two lower ANSI colors that should be some form 
        # of gray for normal operation #8 (Bright/Bold Black) and 
        # #7 (Dark/Unbold White), so we use them for 60% and 80% (the two
        # pallete #s where the pre-defined versions are furthest from 
        # exactly 60% and 80% respectively.
        #
        # So anyhow, that's whats going on with this

        XTERM256_GRAY_START = 232
        XTERM256_GRAYS = [
            0x08, 0x12, 0x1c, 0x26, 0x30, 0x3a, 0x44, 0x4e, 0x58, 0x62, 0x6c,
            0x76, 0x80, 0x8a, 0x94, 0x9e, 0xa8, 0xb2, 0xbc, 0xc6, 0xda, 0xe4,
            0xee
        ]
        XTERM256_10PERCENT_GRAYS = [2, 4, 7, 9, 12, 14, 17, 19, 21 ]

        for i, gray_index in enumerate(XTERM256_10PERCENT_GRAYS):
            gray_index = XTERM256_10PERCENT_GRAYS[i]
            if i == 6:
                palette_index = 8
                color = 153
            elif i == 8:
                palette_index = 7
                color = 205
            else:
                palette_index = XTERM256_GRAY_START + gray_index
                color = XTERM256_GRAYS[gray_index]

            pct = (i + 1) * 10
            name = "Gray{:d}".format(pct)
            self.palette[name] = Color(name,
                                       "G{:d}".format(pct),
                                       palette_index,
                                       color,
                                       color,
                                       color)

    def print_vim_config(self):
        for st in self.style_list:
            print st.vim()

    def print_vim_highlights(self):
        txt_list = []
        for space_count, st in enumerate(self.style_list):
            txt_list.append("{:10s}".format(st.test_str(st.hi_grp)))
            if (space_count + 1 % 7 == 0 or st is self.style_list[-1]):
                print ' '.join(txt_list)
                txt_list = []

    def print_named_styles(self):
        #bgpalette = [c for c in self.palette.values() if c.is_bg()]
        bgpalette = self.palette.values()
        for b in bgpalette:
            txt_list = []

            prefix = Style('{:3s}: '.format(b.short), b).test_str()
            print prefix, 
            for space_count, a in enumerate(self.palette.values()):
                if space_count + 1 % 13 == 0:
                    spacer = '\n      '
                else:
                    spacer = ' '
                s = Style('{:3s}'.format(a.short), a, b)
                txt_list.append(s.test_str())
                txt_list.append(spacer)
            print ''.join(txt_list)

    def print_all_colors(self):
        s = []
        for i in range(255):
            if i + 1 % 16 == 0:
                spacer = '\n'
            else:
                spacer = ' '
            s.append("{}[{};{};{}m{:03d}{}[m{}".format(
                ANSI_ESC,
                ANSI_256_FG,
                ANSI_256,
                i,
                i,
                ANSI_ESC,
                spacer))
        print ''.join(s)

    def process_file(self, src, dest):
        self.parse_pat = re.compile(r'\s*"\s*' + KEYWORD + '\s*(.*)')

        self.style_list = []
        in_generated_content = False

        for line in src:
            m = self.parse_pat.match(line)

            # Generated or Non-keyword content
            if not m:
                if not in_generated_content:
                    dest.write(line)
                continue

            # Begin marker (generate content)
            if m.group(1) == AUTOGENERATED_BEGIN:
                dest.write(line)
                if in_generated_content:
                    raise ParseError(line, "2nd {} detected".format(
                        AUTOGENERATED_BEGIN))

                for st in self.style_list:
                    dest.write("{}\n".format(st.vim()))
                    in_generated_content = True
                continue

            # End marker
            if m.group(1) == AUTOGENERATED_END:
                dest.write(line)
                if not in_generated_content:
                    raise ParseError(line, "{} detected without {}".format(
                        AUTOGENERATED_END, AUTOGENERATED_BEGIN))
                in_generated_content = False
                continue

            attrs =  m.group(1).split()
            if not attrs:
                raise ParseError(line, "No content after " + KEYWORD)

            understyle = None
            understyle_color = None
            bg_color = None
            fg_color = None

            # Process optional leading [MOD]
            mod = False
            if attrs[0] == MODIFIER:
                mod = True
                attrs = attrs[1:]

            # Process hilight group
            hi_group = attrs[0]
            attrs = attrs[1:]

            # Process optional leading [[understyle_color] understyle]
            for sym in UNDERSTYLES.keys():
                if sym in attrs:
                    x = attrs.index(sym)
                    if x > 1:
                        raise ParseError(line, "Style must be defined first")
                    understyle = UNDERSTYLES[attrs[x]]
                    if x == 1:
                        if not attrs[0] in self.palette:
                            raise ParseError(line, "Invalid understyle color: " 
                                             + attrs[0])
                        understyle_color = self.palette[attrs[0]]
                    attrs = attrs[x + 1:]
                    break

            # Process optional trailing [on bg_color]
            if "on" in attrs:
                x = attrs.index("on")
                x += 1 # We're interested in the subsequent item
                if len(attrs) != x + 1:
                    raise ParseError(line, "BG color must be defined last")
                if attrs[x] not in self.palette:
                    raise ParseError(line, "Invalid BG color: " + attrs[x])
                bg_color = self.palette[attrs[x]]
                attrs = attrs[:-2]

            # Process optional [fg_color]
            if len(attrs) > 1:
                raise ParseError(line, "Unexpected extra content encountered:")

            if len(attrs) == 1:
                if attrs[0] not in self.palette:
                    raise ParseError(line, "Invalid FG color: " + attrs[0])
                fg_color = self.palette[attrs[0]]

            self.style_list.append(
                Style(
                    hi_group,
                    fg_color,
                    bg_color,
                    understyle,
                    understyle_color,
                    mod,
                    m.group(1)
                )
            )
            dest.write(line)

sample = [
    '" AC: Warrior',
    '" AC: Monk',
    '" AC: Mage',
    '" AC: Rogue on Shaman',
    '" AC: on Shaman',

    '" AC: _ Paladin',
    '" AC: ~ DarkWarlock',
    '" AC: _ Black on Warrior',
    '" AC: ~ on Shaman',

    '" AC: Druid _ Warrior',
    '" AC: Hunter ~ Mage',
    '" AC: Monk _ Rogue on Shaman',
    '" AC: Warlock ~ on Shaman',
]

# TODO: Exception test and unit test
# Finish!!


arg_parser = argparse.ArgumentParser(description='Manage VIM Colors')
arg_parser.add_argument('-f', dest='vimfile', default=CFG_DEFAULT_COLOR_FILE,
                        action='store', help='vim file to process')
arg_parser.add_argument('-hl', dest='print_hl', action='store_true',
                        help='print current highlights')
arg_parser.add_argument('-a', dest='print_256', action='store_true',
                        help='print all 256 xterm colors')
arg_parser.add_argument('-s', dest='print_named', action='store_true',
                        help='print all palette styles')
args = arg_parser.parse_args()

sm = StyleMaster()
read_only = args.print_hl or args.print_256 or args.print_named

vimfile = CFG_DEFAULT_COLOR_FILE
tmpfile = vimfile + '.tmp'
with open(tmpfile, 'wt') as tmp:
    with open(vimfile,'rt') as f:
        sm.process_file(f, tmp)

if args.print_hl:
    sm.print_vim_highlights()
if args.print_256:
    sm.print_all_colors()
if args.print_named:
    sm.print_named_styles()

if (read_only):
    os.remove(tmpfile)
else:
    shutil.move(tmpfile, vimfile)
